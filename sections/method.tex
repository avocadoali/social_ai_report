\section{Method}

In this section, we detail the methodology employed to determine the optimized integration model
along with the implementation steps undertaken to validate our approach.

\subsection{Dataset Description} 
For our experimentation, we utilized the inD, exiD, and rounD datasets provided by the ika 
of RWTH Aachen University.
The datasets offer vehicle trajectories recorded at German intersections, highway exits, and entries, 
and roundabouts, respectively. 
Additionally, the datasets were provided with a tool that allowed us to visualize them for better understanding. 

\subsection{Model Selection Process} 
Our model selection process involved a systematic trial and error approach with a total of 8 different models. 
Each model underwent an evaluation process to assess its ability to accurately predict vehicle acceleration across 
various scenarios. 
Ultimately, the following linear model emerged as the most suitable choice based on its superior performance metrics.

\begin{align}
    a(k) &= \bar{c}_1 \bigl( s(k+1) - s(k) - v(k) \bigr) -\bar{c}_2 a(k-1) \\
    a(k) &= \bar{c}_3 \bigl( v(k+1) - v(k) \bigr) -\bar{c}_4 a(k-1) 
\end{align}

This linear model is then solved by linear regression. 
After training the model on the acceleration set from our dataset, we can rearrange the formulas
to determine the distance and velocity formulas
\begin{align}
    s(k+1) &= s(k) + v(k)+ c_1 a(k) + c_2 a(k-1) \\
    v(k+1) &= v(k) +                c_3 a(k) + c_4 a(k-1)
\end{align}


The constants can then be determined through these calculations:
\begin{align}
   c_1 &= \frac{1}{\bar{c}_1} \\
   c_2 &= \bar{c}_2 \cdot c_1 \\
   c_3 &= \frac{1}{\bar{c}_3} \\
   c_4 &= \bar{c}_4 \cdot c_3
\end{align}

By rearranging the model as such, we specifically ensure that for both $s(k)$ and $v(k)$ we receive the same 
acceleration, as we are training both models on the same acceleration set.
Thus, we receive a proper integration method for the data set on which we trained the model, which solves the 
problems of the mismatched acceleration in previous attempts.

\subsection{Training and Testing Procedure} 
For training the model, we used the $LinearRegression()$ function, provided by the sci-kit-learn Python library to train our linear model.
The $train\_test\_split()$ function was utilized, with a test size of 0.3, to ensure a sufficient amount of data 
for evaluation.

\subsection{Evaluation Metrics and Results} 
The performance of our linear model was assessed using common metrics for linear regression, including 
R-squared (r2) and Mean Squared Error (MSE). 
Detailed evaluation results, including comparisons with the old method, will be provided later in the report, 
offering insights into the model's predictive capabilities.

